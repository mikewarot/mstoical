
----{ Array handling words }- - - -

]@

   "ary[ 1 ]@"
   Push element number TOS from array TOS-1 onto the stack. If TOS is negative,
   index from the end of the array.

]!

   "0 ary[ 3 ]!"
   Store TOS-2 in element TOS of array TOS-1. If TOS is negative, then it is
   taken to be an index from the last element of the array.

]push

   "'foo ary[ ]push"
   Extend array TOS to include TOS-1.

pop

   "ary[ ]pop ="
   Shorten array at TOS by one, leaving the orphaned element on the stack.
   If there are no elements left to pop, then return a stack marker.

]delete

   "1 ary[ 3 ]delete"
   Remove TOS-2 elements from array TOS-1, starting at index TOS and moving
   tword the end of the array. Array will be resized as necessary.

]insert

   "[ 1 2 3 ] ary[ 3 ]insert"
   Insert TOS-2 many elements from the stack into the array TOS-1 starting at
   offset TOS. Array will be resized as necessary.

)@

   "hash( 'foo )@"
   Lookup the key named by TOS in the associative array at TOS-1. Return
   value.

)!

   "0 hash( 'foo )!"
   Store TOS-2 as the value of key TOS in the hash TOS-1. If the key already
   exists, it's value will be replaced.

)delete

   "hash( 'foo )delete"
   Delete the key named at TOS from the associative array at TOS-1.

array

   "[ 1 2 3 ] 'foo array"
   Define an array. Name is at TOS, count at TOS-1, and first element at TOS-n

hash

   "[ 'key1 1 'key2 2 'key3 3 ] 'foo hash"
   Define an associative array (hash table). The hash will grow and shrink
   as keys are added and deleted. There may be no duplicate keys, and the
   order in which keys were added cannot be retrieved. It is an error to
   initialize a hash with an odd number of elements.
   
   Name is at TOS, count at TOS-1, and first element at TOS-n

]?
   "ary[ 0 ]?"
   Type the contents of element TOS of array TOS-1

)?
   "hash( 'foo )?"
   Type the value of the key TOS in the hash TOS-1

----{ Binary operators }- - - -

add

   "1 2 +"
   Perform floating point addition of TOS and TOS-1.

-

   "4 2 - ( 2 )"
   Subtract TOS from TOS-1.

/

   "10 5 / ( 5 )"
   Perform floating point division of TOS-1 by TOS.

*

   "5 2 * ( 10 )"
   Multiply TOS-1 by TOS.

mod

   "10 4 mod ( 2 )"
   Integer divide TOS-1 by TOS, and
   return the remainder.

/mod

   "10 5 /mod - ( 2 0 )"
   Integer divide. Leaves both quotient and remainer on stack.

and

   Perform bitwise AND on TOS and TOS-1.

or

   Perform bitwise OR on TOS and TOS-1

xor

   Perform bitwise eXclusive OR on TOS and TOS-1.

feq

   "1 1 feq"
   Test TOS and TOS-1 for equality.

fne

   "1 2 fne"
   Test TOS and TOS-1 for inequality.

lt

   "1 2 lt"
   TRUE if TOS-1 is less than TOS.

gt

   "2 1 gt"
   TRUE if TOS-1 is greater than TOS.

le

   "1 1 le"
   TRUE if TOS-1 is less than or equal to TOS.

ge

   "1 1 ge"
   TRUE if TOS-1 is greater than or equal to TOS.

+

   "1 1 +"
   Add TOS and TOS-1. In the case of strings, TOS will be appended to TOS-1.

eq

   Compare TOS against TOS-1 for equality

----{ Compiler words }- - - -

exit

   Exit thread. Calling exit from the main thread, or with threads disabled,
   causes program termination. 

^
   Clear the end-of-command flag. Thereby allowing the continuation of,
   otherwise executable, lines.

%
   "#! /usr/bin/stoical"
   Set the end-of-line flag to true. This causes the remainder of the
   line to be ignored and discarded. Used for comments.

%%
   "%% line of text"
   Call MSG against the remainder of the line, including a newline character.

eoc

   End of command flag.

eol

   End of line flag.

stack
   "1 2 3 stack"
   Non-destructively print the parameter stacks contents.

stack
   "1 2 3 stack"
   Non-destructively print the loop stacks contents.

vocab
   Print contents of the vocabulary on top of the vocabulary stack.

decompile

   "() foo DECOMPILE"
   Print a source version of the word addressed by TOS.

vstack
   List the vocabularies on the vocabulary stack.

rtn

   Exite the process with the return value of TOS.

bye

   Exit the entire process. (with return value of zero);

inspect
   Display some memory usage information.

prompt

   Display the compiler prompt on the output device.

compile

   Compile textual instruction from the TIB, stacking them onto the compile
   stack as we go.

clearcst

   clear the compile stack

eval

   Execute STOICAL source code in string at TOS.

execc

   Execute the contents of the compile stack.

----{ Words for constructing conditionals }- - - -

mark?

   Return TRUE or FALSE based on whether TOS is a mark.

check

   Push current nesting depth.

+check

   Increment nesting depth.

-check

   Decrement nesting depth, generating a syntax error if the result is less
   then zero.

{
   Begin clause

}
   End clause. 

(else)

   Increments instruction pointer by the contents of the next
   value in the instruction steam.

(if)

   Tests TOS. If zero, the instruction pointer is incremented. Otherwise,
   instruction pointer is incremented by the contents of the next value in the
   instruction stream.

{if

   "n {IF { ... }"
   Conditionally execute the following clause.
   Increment IP if TOS is equal to the FALSE value.

{else
   "n {if { ... } {else { ... }"
   Rewrite the compile stack to look like:
   
   "{ifelse { ... } ({else) { ... }"

(else)

   Skip over the clause following us in the instruction stream

{ifelse
   "{ifelse { true clause } ({else) { false clause }"

if{
   "n if{ ... }"
   Execute following clause if TOS is not equal to FALSE. Short-hand for "{if
   {".

}else{
   "if{ ... }else{ ... }
   Terminate IF{ clause. The following clause will be executed if the preceding
   IF{ evaluated to FALSE. Short-hand for "} {else {".

if
   "n IF ... then"
   Conditionaly execute the instructions. The instructions following IF will be
   executed if TOS is not FALSE upon invokation.

else
   "n if ... ELSE ... then"
   Instructions following ELSE will be executed if the preceding IF evaluated
   to FALSE.

then
   "n if ... else ... THEN"
   Terminate preceding IF/ELSE.

----{ Constants defined by the compiler }- - - -

true

   Push -1.

false

   Push 0.

----{ Dictionary manipulation words }- - - -

(:)

   Push the Instruction Pointer onto the return stack. Set IP to
   point just before the first location in the current word's parameter field.

({:)

   Execute a clause as if it were a word.

:{
   Begin a colon definition.  Push the address of (:{) onto the compile stack,
   and open a new clause.

(:{)

   "'foo :{ bar }"
   Create a new executable word in the dictionary consising of the following
   clause, and named by the string at TOS.

):{

   "'foo :( s f ):{ bar }"
   Begin a type checked definition.  Pop the top entry off of the vocabulary
   stack. Push the address of ():{) onto the compile stack. Open a new clause.

():{)

   Begin typed colon definition.  There should be a type-number list
   representing the named word's type mask on the stack, terminated by a
   marker. Name follows this. The new clause will be appended to the word's
   clause table, or the word will be created if it doesn't exist. A new word
   will also be created if the previously defined version wasn't defined with
   type-checking enabled.

enter

   "'name enter"
   Create an entry 'name in the vocabulary pointed to by CURRENT.

({)

   Push IP onto the block stack. Set ip to point just before the first
   instruction of this clause.

(b{)

   Similar to ({), except that IP - 3 is stored on the block stack instead.
   This results in the clause returning to a point two instructions head of
   where it was invoked. WHILE and friends exploit this behavior.

(})

   Return from clause. Pop IP from the block stack.

{}>
   Move the clause at the top of the compile stack onto the parameter stack,
   marking it for GC.

(;)

   Pops an instruction pointer off the return stack. Used to terminate a colon
   definition's instruction portion.

immediate

   "'foo : 1 = ; immediate"
   Set the immediacy flag of the most recently defined word.

(constant)

   Push the contents of the current word's parameter field onto the stack.

fconstant

   "1 'foo constant"
   Define TOS to be a constant, with the value of TOS-1.
   
   Execute ENTER. Add set the code field of the new dictionary entry to point
   to (constant), place the value from TOS-1 in the word's parameter field.

(variable)

   Push the address of the current word onto the stack.

((variable))

   

definitions

   Copy the top of the vocabulary stack into "current".

stoical<
   Push a pointer to the STOICAL kernel vocabulary onto the vocabulary stack.

(branch)
   Push the pointer stored in the calling word's parameter field onto
   the vocabulary stack.

branch

   "'foo branch"
   Create a branch off of the current vocabulary, with the name found in TOS.

disregard
   "'foo disregard"
   Works like FORGET, except that it removes ONLY the specified vocabulary
   entry. (only searches CURRENT for NAME)

>
   Pop off the top of the vocabulary stack.

address

   "'foo address"
   
   Lookup the address of the string TOS in the dictionary. Error if
   undefined.

()
   This word looks up the address of the following word in the vocabulary
   and replaces itself with code to push that address onto the stack at
   runtime. Lookup next word. Push address of l() onto the compile stack. Push
   address we found onto compile stack. (in a cell).

//
   "'foo : // 1 = // ;"
   Complement compiler state. A True state causes all words to act as Immediate.

self

   Push a pointer to the vocabulary entry for the calling word onto the stack.

:
   "'foo : ... ;"
   Begin colon definition. Execute :{.

;
   "'foo : ... ;"
   Terminate colon definition. Execute }.

}>
   "{ }>"
   Push the address of the preceding clause onto the parameter stack.
   Short-hand for "} {}>".

types<

   The TYPES< vocabulary contains constants that map type names to their numeric
   values. The the word :( pushes this vocabulary onto the vocabulary stack to
   expose the names durring definition. Both the abbreviated and verbose
   type names may be used here. Below is a list of the short and long names:
   
   short		long
   --------
   *		bah	( don't care )
   f		float
   s		string
   r		reference
   p		pointer
   io		stream 	( file / socket )
   a		array
   h		hash 
   c		clause

constant

   "1 'foo CONSTANT"
   Define a new constant with the name at TOS and the value of TOS-1.

variable

   "1 'foo VARIABLE"
   Define a new variable with the name at TOS and the value of TOS-1.

~
   "'foo ~"
   This word, pronounced "defer", is equivalent to "'foo address exec".

recurse
   "'factorial : dup 1 ne if dup 1- recurse * then ;"
   Recursively execute the word being defined. Equivalent to SELF EXEC.
   Recursion beyond the depth of the return stack is not currenly possible.

----{ Error handling words }- - - -

errch

   Test for under/overflow on all stacks and print appropriate error
   message.

abort

   Reset compiler to a sane state, and return control to the keyboard.

----{ Input / Output words }- - - -

chdir

   "'.. chdir"
   Change to the directory named by TOS. Returns a boolean value indicating
   success

mkdir

   "'foo 0 mkdir"
   Create a new directory. With name at TOS-1, and mode at TOS. Returns a
   boolean value indicating success.

rmdir

   "'foo rmdir"
   Remove the directory named in the string at TOS. Will fail if the directory
   is not empty. Returns a boolean success.

unlink

   "'foo unlink"
   Remove file named by TOS from the file system. Returns a boolean success.

mkfifo

   "'foo mkfifo"
   Create a special file of the FIFO variety with the name at TOS-1, and the
   permissions at TOS. Returns boolean success.

umask

   "0 umask"
   Set the process's new file permissions mask to the value at TOS.

open

   "'foo 'r+ open"
   Open the file named by TOS-1 with the mode spelled out in the string at
   TOS. Modes are of the form "r+", etc. Returns a handle for the file, and
   a boolean success.

close

   "'foo 'r open drop CLOSE"
   Close the file handle at TOS and free its resources

write

   "address count handle WRITE"
   Copy 'count' bytes from 'address' to the file or socket described by 'handle'
   Returns the number of bytes actually transfered.

read

   "address count handle READ"
   Copy 'count' bytes form the file or socket described by handle, into the
   memory at 'address' Returns the number of bytes actually transfered.

writeln

   "'foo handle WRITELN"
   Write the string at TOS-1 to the file or socket described by the handle
   at TOS.

readln

   "handle READLN"
   Read a line of text from a file/socket handle. Return the text (including
   newline) and TRUE if a string could be read, or FALSE if end of file was
   reached and no bytes were read.

flush

   "handle flush"
   Flush the buffers for the file/socket represented by the handle at TOS.

seek

   "offset whence file seek"
   Change the possition indicator of the given stream.  TOS-3 is the number of
   bytes to move. TOS-2 is one of 1, 0 or -1, for makeing the offset relative
   to the start of the file, the current possition, or the end of the file,
   respectively.

stat

   "'filename [ 'mode 'atime ... ] stat"
   Get file statistics. TOS (n) is number of items in attribute list.
   TOS - n is the name of the file to stat. Leaves stat values in the order
   specified on the stack and TRUE if all went well. Otherwise, just return
   FALSE.
   
   The attribute list may contain any number of the following:
   
   'dev		- device
   'ino		- inode
   'mode	- permissions
   'nlink	- number of hard links
   'uid		- user id of owner
   'gid		- group id of owner
   'rdev	- device type
   'blksize	- block size for file i/o
   'blocks	- number of blocks allocated to file
   'atime	- time of last access
   'mtime	- time of last modification
   'ctime	- time of last change

(get)

   Variable containing address of current character input word.

(put)

   Variable containing address of current character output word.

(getln)

   Variable containing address of current line input word.

(putln)

   Variable containing address of current line output word.

get

   Execute word who's address is stored in the variable IN. The word to be
   executed should read a single character from the input device, and return
   it an integer representing the ascii value entered.

put

   "48 put"
   Execute word who's address is stored in the variable OUT. The word to be
   executed should print the single character represented by the ascii
   code at TOS, to the output device.

ttyput

   "48 ttyput"
   Output character to terminal

ttyget

   Input a character from terminal.

getln

   Execute word who's address is stored in the variable INLN. The word to be
   executed should read a line from the input device, and return it as a
   string striped of its newline.

putln

   "'foo count putln"
   Execute word who's address is stored in the variable OUTLN. The word to be
   executed should output TOS many bytes of the memory at TOS-1 to the output
   device.

ttyputln

   "'foo count ttyputln"
   Output string to terminal

ttygetln

   Input line from the terminal (strip newline)

opendir

   "'. opendir"
   Open directory named by TOS. Leaves on the stack a directory pointer and
   TRUE if call succeeds, otherwise it just leaves FALSE.

closedir

   "dir close"
   Close the directory referenced by the handle at TOS.

readdir

   "dir readdir"
   Push the name of the next entry in directory pointed to by TOS onto
   the stack and TRUE. If end of directoy is hit, just push FALSE.

socket
   "'inet 'stream 'tcp socket"
   Create an endpoint for communication. This can later be used by connect
   and listen to create a connection. 
   
   'domain 'type 'protocol socket
   
   Domain should be a string matching one of the following:
   "unix"	local (unix) communication
   "inet"	ipv4 protocols
   "inet6"	ipv6 protocols
   "packet"	low level packet interface.
   
   Type should match one of:
   "stream"	reliable, two-way, and connection based.
   "dgram"	connectionless, unreliable and fixed length.
   "seq"	a hybrid of stream and dgram.
   "raw"	raw protocol access.
   
   Protocol can be any protocol that the system supports.
   These should be listed in the /etc/protocols file on most systems.
   Those most likely to be used include "tcp", "udp", and "icmp".
   
   FIXME: Some more error checking wouldn't hurt.

bind
   "'port sock bind"
   Bind socket at TOS to port at TOS-1 ( or unix name as the case may be ) in 
   the domain at TOS-2.

listen
   "4 sock listen"
   Initialize socket at TOS for listening. Queue TOS-1 many requests.

accept

   "sock accept"
   Accept a connection on the socket at TOS. Returns a new socket
   representing the connection accepted.

connect

   "'name 'port sock connect"
   Initiate a connection to 'name at port 'port on the socket sock.

shutdown
   "sock 1 shutdown"
   Shut down one direction of a full-duplex connection.
   Socket is at TOS. TOS-1 specifies which direction:
   0 - incoming.
   1 - outgoing.
   2 - both.

sendfile
   "start count dest src SENDFILE"
   Copy data between file descriptors. DST should point to a file or socket
   opened for writing. SRC should point to a file opened for reading.
   Copying will begin at offset START in SRC, COUNT many bytes will be
   transfered. Returns the number of bytes actually copied. 

frdline

   Just line rdline, but when input is from something other than a 
   terminal. Routines that change the input stream must also change
   the code pointer in the rdline vocabulary entry accordingly.
   (This is to avoid constantly checking where input is coming from)

rdline

   Read a line of input into the Terminal Input Buffer.

=

   Type the top of stack in a pretty fashion.

cr

   Output a newline.

space

   Output a space.

spaces

   Output TOS spaces.

tab

   Output a tab character.

----{ Words for constructing iterations }- - - -

i

   "4 ( i = )"
   Push innermost loop index onto the parameter stack.

j

   "4 ( 4 ( j = ) )"
   Push next innermost loop index onto the parameter stack.

k

   "4 ( 4 ( 4 ( k = ) ) )"
   Push next, next innermost loop index onto the parameter stack.

redo
   "'foo : 1 = redo ;"
   Cause the calling word to begin execution over at its first instruction.
   This effectively creates tail-recursive calls.
   
   Execute the word addressed by the self pointer on top of the return stack.
   (the word being executed)

({do)
   Setup loop stack in anticipation of ({loop)

({loop)
   Inrement the top of the loop stack and compare the result against TOP-2
   of the loop stack. Result is grater than or equal to TOP-2, then the
   loop stack is cleaned up and the loop execution continues at the next
   instruction. Otherwise, the loop is incomplete, so we jump back one
   instruction to the begining of the loop.

({+loop)

   Add TOS to top of loop stack, otherwise the same as loop.

{loop
   "hi lo {loop { ... }"
   Rewrite the compile stack to look like:
   
   ({do) ({loop) nop nop b{ ... b}

{+loop
   "hi low {+loop { ... incr }"
   Rewrite the compile stack to look like:
   
   hi low (do) (+loop) nop nop b{ ... incr b}

({()

   Note that this version differs from STOIC's in that it sets up the loop
   stack so that '-i' produces sane results.
   
   Increment IP by the value of the next item in the instruction stream if TOS
   is less than, or equal to 0. This handles the case that the iteration count
   given to us amounts to 0 times. Otherwise, push a zero and the value of TOS
   plus 2, followed by TOS, onto the loop stack.

({))
   Decrement the value on top of the loop stack. If the result is zero, then
   the loop is over. Clean up the loop stack.
   Otherwise, decrement the instruction pointer to repeat the loop.

{(
   "time {( { ... }"
   Rewrite the compile stack to look like:
   
   ({() { ... } ({))

()do)
   Push an empty cell onto the loop stack. Move the hash pointer at TOS onto
   the loopstack, and follow it with an empty string.

(){each)
   Place the next key from the hash at LST-1 on top of loop stack.  If there
   are no more keys, then clean up the loop stack and skip over the next code
   block to terminate the loop. Likewise terminate the loop if BREAK has been
   called. Otherwise, jump back to the begining of the loop.

){each
   "hash( ){each ... }"
   Rewrite the compile stack to look like:
   
   "()do) (){each) nop { ... }"

{until
   "{ ... } {until"
   Backup an instruction if TOS is FALSE.

{while
   "{ ... } {while { ... }"
   Rewrite the compile stack to look like this:
   
   { ... } {if b{ b}

break

   "5 ( i 3 eq if BREAK then i = )"
   STOIC calls this EXIT, but that seems ambiguous.
   Break is used to unconditionally terminate the inntermost looping construct
   upon the next iteration. That is, the example above will print "5 4 1"
   before ending.
   
   Set TOS and TOS-2 of loop stack to 1.

}until
   "{ ... n }until"
   Execute preceding clause until TOS is not equal to FALSE. Short-hand for
   "{ ... n } {until"

}while{
   "{ ... n }while{ ... }"
   Evaluate precedeing clause. If not equal to FALSE, then execute following
   clause. Repeat ad infinitum.

loop{
   "hi lo loop{ ... }"
   Execute the following clause HI times, running an index from LO to HI. These
   indices may be retrieved through the I family of words. No action is
   performed if HI is less than or equal to LO. Short-hand for "{loop {".

+loop{
   "hi lo +loop{ ... incr }"
   Similar to LOOP{, except that the index is incremented by the value at TOS
   as of the end of the clause, instead of by one. Short-hand for "{+loop {"

)each{
   "hash( )each{ i = }"
   Iterate over the keys of the hash referrenced by TOS; Executing the following
   clause once for each key. Within this context "I" pushes a string representing
   the current hash key. Due to the nature of hash tables, keys may appear to
   be in random order.

(
   "5 ( ... )"
   Begin 'parenthesis loop'. Iterate over the following clause TOS times, running
   and index from TOS to 1. Execute {(, Execute {. 

)
   "5 ( ... )"
   Terminate parenthesis loop. Execute }, push the address of ({)) onto the
   compile stack.

begin
   "begin ..."
   Mark the beginning of an END/REPEAT construction.

end
   "begin ... n end"
   Jump back to the preceeding BEGIN if TOS equals FALSE.

----{ Literal handling words }- - - -

l()

   Push the literal following us in the intruction stream onto the stack,

----{ Arithmetic words }- - - -

rand

   Return a pseudo-random number.

srand

   "123 srand"
   Reset the random seed to the value of TOS.

radix

   Current number conversion radix.

#

   "<# # #>"
   Print single digit in current radix. Divide the number at TOS by the current
   radix, leaving the quotient on the stack. Convert the remainder to an ascii
   digit and output it using #put.

#put

   "40 <# #s #>
   Convert entire number to a string and output it. Execute # until TOS becomes
   zero. # will always be executed at least once.

<#>

   Convert the number at TOS to a string. Leave the length at TOS, and a pointer
   to the first character of the string at TOS-1.

octal

   Set radix to octal.

decimal

   Set radix to decimal.

hex

   Set radix to hexadecimal.

----{ Regular expression words }- - - -

x
   Set option flags for the next regular expression. Takes next word in the
   keyboard buffer and evaluates each leter as a flag, logically OR'ing them
   together into re_flags.
   
   flag	meaning						Expression Modifiers
   ---------------
   b	use basic regex syntax instead of extended
   s	perform substitution
   i	ignore case
   g	match globally (ie, match all occurrences)
   m	treat as multiple lines
   n	need not return the matches, just a boolean

rs()
   Regular expression substitution. Replacement string is at TOS, search
   string at TOS-1, and a pointer to the precompiled RE follows us in the
   instruction stream. Returns the new string and the number of times the
   pattern matched if a substitution could be made, otherwise it returns
   the string searched (unchanged) and FALSE.

r()
   Attempt match the string at TOS against the precompiled regular expression
   pointed to by the next item of instruction stream. Leaves submatches on
   the stack, followed by a count, or FALSE if no matches could be found.

----{ Words that change how STOICAL sees program source }- - - -

load

   "'filename load"
   Transfer execution to the STOICAL source file named by TOS. Internally,
   load will the current input file pointer, rdline Code Address, and prompt
   CA on the loop stack, and then begin executing the file named by TOS.

include

   "'filename include"
   This is the same as load, with the filename being relative to the stoical
   library root. (/usr/local/lib/stoical/)

;f

   Close the current input file, and restore input, rdline and prompt
   from the loop stack to their values at the last LOAD.

----{ Stack manipulation words }- - - -

cells

   "CELLS idrop"
   Push the number of occupied parameter stack cells onto the stack.

mark

   Leave a mark on the stack that is unique from any other object that
   might occupy a stack cell. This mark can later be used to restore the
   stack to the level it was at when the mark was placed.

swap

   "( a b - b a )"
   Swap TOS with TOS-1.

drop

   "( a - )"
   Discard the value on top of the stack.

dup

   "( a - a a )"
   Duplicate TOS.

over

   "( a b - a b a )"
   Duplicate TOS-1.

nip
   "( a b - b )"
   Remove TOS-1.
   Note: STOIC calls this word UNDER (which is decieving). In my view UNDER
   should work like TUCK.

tuck
   "( a b c - a c b c )"
   Tuck inserts a copy of TOS before TOS-1.

-rot

   "( a b c - c a b )"
   Rotate the top three stack cells backwards by one position.

+rot

   "( a b c - b c a )"
   Rotate the top three stack cells forwards by one position.

flip

   "( a b c - c b a )"
   Swap TOS and TOS-2.

idup
   "( a b c 3 - a b c a )"
   Duplicate the TOSth element of the stack.

idrop
   "( a b c 3 - b c )"
   Discard the TOSth element of the stack.

<l

   "1 <l"
   Transfer TOS to the loop stack.

l>

   "1 <l L>"
   Push the top of the loop stack. 

<c

   "() foo <C"
   Transfer pointer value at TOS to the compile stack.
   Only pointers may exist on the compile stack, anything else is in error. 
   Note: STOIC calls this C,. 

c>

   Push the top of the compile stack.

.t
   Replace TOS with the type of what we replaced. 

retype

   "'foo 3 retype"
   Set type of TOS-1 to the value of TOS. 

[[
   "[[ 1 2 3 ]]"
   Leave a mark on the stack.

]]
   "[[ 1 2 3 ]]"
   Pop items, up to and including a mark, from the stack.

l]]
   Pop items, up to and including a mark, from the loop stack.

([)

   "[ 1 2 3 ]"
   Push parameter stack pointer onto the loop stack. ']' will use this
   later.

(])

   "[ 1 2 3 ]"
   Calculate how many items have been added to the parameter stack since
   '[' left the pointer for us on the loop stack. Push the result. 

[
   Execute +check. Push the address of ([) onto the compile stack.

]
   Execute -check. Push the address of (]) onto the compile stack.

----{ String handling words }- - - -

cat

   "'foo 'bar cat"
   Concatenate two strings.
   Note: use + instead.

count

   "'foo COUNT"
   Leaves the address of the preceding string plus one at TOS-1 and it's count
   byte at TOS.

type

   "'foo count TYPE"
   Output a string who's address is at TOS-1 and who's length is at TOS.

stype

   "'foo count STYPE"
   Takes the same input as TYPE, but leaves its output on the stack instead
   of printing it. That is to say, given a pointer and a count byte, it will
   return a pointer to a new string beginning with that count byte, and with
   the same contents as the source string. 

msg

   "'foo msg"
   Print the string addressed by TOS.
   Note: use = instead.

$eq
   Compare two strings.

$ne
   Compare two strings.

word

   Scan keyboard buffer for the next word. Skip leading white space.
   Treat Everything between quotes as a single word. Set eol to true if the
   end of line was reached while scanning.

iliteral

   "( '1.23 - 1.23 )"
   Evaluate the string at TOS. If the string represents an integer or
   floating point literal then leave its value at TOS-1 and TRUE at TOS.

string

   Return a pointer to an emtpy string of length TOS.

ascii
   "ascii f"
   Replace self with the literal value of the first character of the next
   word in the TIB

----{ Words for interacting with Unix }- - - -

args[

   
   Array containing the command line arguments passed by the shell. 
   Element zero is the name of the program.

system

   "'ls system"
   Execute a shell to run the command reflected in the string at TOS.
   Leaves the shell's return value on the stack.

env>

   "'PWD env>"
   Replace string at TOS with the STRING value of the environment variable by
   that name. (Or FALSE if not found)

<env

   "'/ 'HOME <env"
   Set environment variable who's name matches the string at TOS to the
   string value at TOS-1

(env)
   "'PWD (env)"
   Declare TOS to be a string constant, and define its contents as the value of
   the environment variable sharing its name (or an empty string if undefined).

----{ Thread handling words }- - - -

thread

   "() foo THREAD detach"
   Launch a new thread.
   Takes as an argument the address of the word that the thread should begin
   execution with. Returns a reference to the new thread. In order for a
   thread's resources to be reclaimed, it is necessary to either JOIN or
   DETACH it.

detach

   "() foo thread DETACH"
   Detach the thread referred to by TOS. Once a thread has been detached
   you cannot retrieve it's return value.

join

   "() foo thread JOIN"
   Wait for thread referred to by TOS to end, and then detach it, freeing
   its resources. Returns the threads exit status.

me

   "ME cancel"
   Push a reference to the calling thread onto the stack

cancel

   "me CANCEL"
   Cancel the thread referred to by TOS.

delay

   "1 0 delay"
   Delay calling thread (not entire process) for TOS-1 seconds and TOS
   nanoseconds.

shared
   "'foo 'bar variable shared"
   Declare the most recently defined word to be shared among threads.  This
   means that STOICAL will serialize access to it in a 'one writer, many
   readers' fashion.

----{ Unary operators }- - - -

1+

   Increment TOS by one.

1-

   Decrement TOS by one.

int

   "( 1.3 - 1 )"
   Round double at TOS to an integer value. Not very pretty, as the gritty bits
   are left to your specific C compiler. But, since I've been GCC-ific so far,
   why stop now? FIXME: My name is pandora. This is my box.

abs

   "( -3 - 3 )"
   Return absolute value of TOS.

bool

   "3 bool not if"
   Convert TOS to TRUE either FALSE. This word is used in situations where
   you would like to use AND/OR/NOT in their logical capacity, but the value
   you are working with may never be TRUE in the stoical sense.

not

   "false NOT"
   Negate each bit of TOS.

eqz

   FALSE if TOS does not equal zero.

ltz

   FALSE if TOS does is not less than zero.

-i
   "4 ( -i = )"
   Push TOS-2 + TOS-1 - TOS - 1 of the loopstack. The effect of this is an
   index like i, but moving in the other direction. In STOICAL, -i can be used
   from with in parenthesis loops, where in STOIC this was erroneous.
   Note: STOIC calls this i' (i prime). I think -i makes the word's function
   more obvious. 

-j
   Similar to -i, but for the next innermost index.

-k
   Similar to -i, but for the next, next innermost index.

exec

   Execute word who's address is at TOS.

----{ Load an store operations }- - - -

@

   "foo @"
   Load the contents of the parameter field of the word who's address is at
   TOS. If threads are enabled and the variable has been marked by the SHARE
   word, then access to it's value will be serialized in a 'one writer, many
   reader' scheme with @ playing the reader.

!

   "1 foo !"
   Store TOS-1 in the parameter field of the variable pointed to by TOS.
   If threads are enabled and the variable has been marked by the SHARE word,
   then access to it's value will be serialized in a 'one writer, many reader'
   scheme with ! playing the writer.

?

   "0 'foo variable foo ?"
   Type the contents of the variable at TOS.

@@

   "bar 'foo variable foo @@"
   Indirectly load TOS. 

1+!

   Increment the variable addressed by TOS.

----{ Variables defined by the compiler }- - - -

pad
   Push the address of the scratch Pad area. The PAD is in the form of a
   string.

warnings

   Change compiler warning verbosity.
   Currently the only meaningful value is FALSE, to disable warnings on word
   redefinitions and the like.

current

   Return a pointer to the current vocabulary for new definitions.

.c

   Push the number of cells used by the compile stack.
   Note: STOIC would have pushed the compile stack pointer.

.l

   Push the number of cells used by the loop stack.
   Note: STOIC would have pushed the loop stack pointer.

.r

   Push the number of cells used by the return stack.
   Note: STOIC would have pushed the return stack pointer.

.v

   Push the number of cells used by the vocabulary stack.
   Note: STOIC would have pushed the vocabulary stack pointer.

.d
   Return a pointer to the bare memory portion of the scratch PAD area.
   
   The original STOIC would return a pointer to the end of the dictionary;
   Usually using it as a temporary space. However, in STOICAL there is no such
   space.

tib
   Push the address of the Terminal Input Buffer onto the stack. The
   TIB looks like any other string.
